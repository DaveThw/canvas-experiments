<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <script>

//3456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 1234567890

    // default values
    var gridSize = 10;
    var canvasWidth = 300;
    var canvasHeight = 300;
    
    // global variables
    var canvasElement;
    var drawingContext;
    var counterElement;
    var nextIdElement;
    var items = [];
    // I use...
    // items[index] to get at a specific item
    // (and items[index].??? to get at that items properties...)
    // items.push(item) to add an item - use items.add(item) instead
    // items.splice(index, 1) to remove an item
    // items.length to get number of items
    // for loop to check through all items
    //   note, we should use "for (var i = items.length; --i >= 0 ; ) {" as (apparently) it is the
    //   fastest way of going through the array.  "for (var i in items) {" shouldn't really be used
    //   on an array, as it can throw up additional 'methods' and things...  see here:
    //   http://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-such-a-bad-idea
    // items = [] to intialise it, once - now moved from init function to initial declaration here
    //
    // Hmm.. okay, here's an idea - seperate the display order (or stacking order) out into a
    // separate array of itemId's.  Then change items into an object, with the itemId being the key
    // of each Item - these can be accessed as items[itemId].
    // Pros - easier direct access to items by their itemId - will be useful in the future
    //      - stacking order becomes an array of itemId's - with 'methods' for re-ordering items
    // Cons - less easy to iterate through all items - using "for (var item in items) {" would also
    //        pick up on other 'methods' and variables within the items object...
    //      - when we delete an item we'd ought to update the stacking order array too (or does it
    //        tidy itself up / fail gracefully when it finds an item that no longer exists..?)
    //         - will need to think about this also for other things that might reference items by
    //           their itemId - like a line linking two items together...
    items.nextItemId = 0;
    items.add = function(item) {
        item.id = items.nextItemId++
        return (items.push(item) - 1)
    }
    items.removeByIndex = function(index) {
        return ( items.splice(index, 1) )
    }

    // 'selection' Object, for keeping track of which items are currently selected
    var selection = new function() {
        this.items = []
        this.count = function() {
            return this.items.length
        }
        this.any = function() {
            return (this.items.length > 0)
        }
        this.clear = function() {
            this.items = []
            return true
        }
        this.add = function(item) {
            index = this.items.indexOf(item.id)
            if (index == -1) {
                return (this.items.push(item.id) - 1)
            } else {
                // don't add item a second time!..
                return index
            }
        }
        this.solo = function(item) {
            this.items = [item.id]
            return 0
        }
        this.remove = function(item) {
            index = this.items.indexOf(item.id)
            if (index != -1) {
                this.items.splice(index, 1)
            }
            return index
        }
        this.isSelected = function(item) {
            return (this.items.indexOf(item.id) != -1)
        }
        this.addAll = function() {
            this.items = []
            // note: here we are looping through the global items array, not our local this.items
            for (var i = items.length; --i >= 0 ; ) {
                this.items.push(items[i].id)
            }
            return true
        }
    }

/************************\
* Shape item definitions *
\************************/

function Rectangle(x, y, width, height, colour, line_width, line_colour) {
    // deal with default values for any missing arguments...
    // (borrowed from here: http://stackoverflow.com/a/9363769)
    switch (arguments.length) {
        case 2:  width = 10;
        case 3:  height = 10;
        case 4:  colour="#fff";
        case 5:  line_width=3;
        case 6:  line_colour="#777";
    }
    // this.type = "rectangle";
    // this.id = newItemId++;
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.colour = colour;
    this.line_width = line_width;
    this.line_colour = line_colour;

    this.draw = function (context, colour) {
        switch (arguments.length) {
            case 0:  context = drawingContext;
            case 1:  colour = this.colour;
        }
    }
}

function Circle(x, y, width, height, colour, line_width, line_colour) {
    // deal with default values for any missing arguments...
    // (borrowed from here: http://stackoverflow.com/a/9363769)
    switch (arguments.length) {
        case 2:  width = 10;
        case 3:  height = 10;
        case 4:  colour="#fff";
        case 5:  line_width=3;
        case 6:  line_colour="#777";
    }
    // this.type = "circle";
    //  could instead use items[i].constructor.name (which gives "Circle")
    // this.id = newItemId++;
    //  now the id is initialised by items.add()...
    this.x = x;
    this.y = y;
    this.radius = this.width = width;
    this.height = height;
    this.colour = colour;
    this.line_width = line_width;
    this.line_colour = line_colour;
    this.cursorStyle = "pointer";

    this.draw = function (context, colour, line_colour) {
        switch (arguments.length) {
            case 0:  context = drawingContext;
            case 1:  colour = this.colour;
            case 2:  if (selection.isSelected(this)) {
                         // item is selected
                         line_colour = "#ff0000";
                     } else {
                         // item not currently selected
                         line_colour = this.line_colour;
                     }
        }
        
        context.beginPath();
        context.arc(this.x, this.y, this.radius, 0, Math.PI*2, false);
        context.closePath();
        
        context.fillStyle = colour;
	    context.fill();
        
        context.strokeStyle = line_colour;
        context.lineWidth = this.line_width;
        context.stroke();
    }
    
    this.mouseOver = function(pos) {
        // var x2 = Math.pow(this.x - pos.x,2);
        // var y2 = Math.pow(this.y - pos.y,2);
        // var r = Math.sqrt(x2 + y2);
        return ( (Math.pow(this.x - pos.x,2) + Math.pow(this.y - pos.y,2)) <= Math.pow(this.radius,2) );
    }
}




function Position(x, y) {
    this.x = x;
    this.y = y;
}

function getCursorPosition(e) {
    /* returns Position with .x and .y properties */
    var x;
    var y;
    if (e.pageX != undefined && e.pageY != undefined) {
        x = e.pageX;
        y = e.pageY;
    } else {
        x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
        y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
    }
    x -= canvasElement.offsetLeft;
    y -= canvasElement.offsetTop;

    var pos = new Position(x, y);
    return pos;
}



/****************\
* Event handlers *
\****************/

// Mouse Click Events sequence:
// 1) MouseDown
// 2) MouseUp
// 3) Click
//
// 4) MouseDown
// 5) MouseUp
// 6) Click
// 7) DoubleClick
//
// Because the browser considers the canvas to be one element (it doesn't know about our 'items'),
// we tend to receive most of these even if the mouse moves about a bit between the MouseDown and
// MouseUp.  If the MouseDown happens outside the canvas, but the MouseUp happens within the canvas,
// then we don't get a Click after the MouseUp.  Pressing Escape between MouseDown and MouseUp
// doesn't appear to cancel the Click.  Doesn't seem to matter how long the pause between the
// MouseDown and MouseUp - we still get a Click.


function canvasMouseDown(e) {
    // button detection needs improving, espeically if this is ever to become cross-browser compatible!.. see here:
    // http://javascript.info/tutorial/mouse-events#getting-the-button-info-which-button
    // or here:
    // http://www.quirksmode.org/js/events_properties.html#button
    if (e.button == 0) {
        // normal left-click
        
        // prevent default actions - in particular for a double click (tends to highlight some text around the canvas!..)
        e.preventDefault();
        // unfortunately this also prevents the canvas from getting the focus when we click on it, which prevents us from receiving KeyDown events...
        // see here for methods to work out if our convas has the focus at the moment (not straight forward!): http://www.whatwg.org/specs/web-apps/current-work/#focus-management-apis
        if ( !(document.hasFocus() && (document.activeElement == canvasElement)) ) {
            // Now, 'manually' pulling focus to the canvas like this seems to move the window around (which I don't really want), so...
            // (window.scrollX and .scrollY don't seem to work..? although they should do! see here:
            // https://developer.mozilla.org/en-US/docs/Web/API/window.scrollY
            // and here:
            // http://stackoverflow.com/questions/3791336/why-were-window-scrolly-and-window-scrollx-introduced )
            // var scroll_x = window.pageXOffset;
            // var scroll_y = window.pageYOffset;
            // This is more robust across various browsers...
            var scroll_x = (window.pageXOffset !== undefined) ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;
            var scroll_y = (window.pageYOffset !== undefined) ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
            canvasElement.focus();
            window.scroll(scroll_x,scroll_y);
        }
        var pos = getCursorPosition(e);
        
        // try to work out if we have clicked on an existing item or not...
        var this_item = which_item(pos)
        
        if (this_item == -1) {
            // we've clicked in empty space...
            if (selection.any()) {
                // one or more items currently selected - unselect everything
                selection.clear();
            } else {
                // nothing currently selected - do nothing for now..?
            }
        } else {
            // we've clicked on an item...
            
            if (!e.shiftKey && !e.ctrlKey && !e.altKey && !e.altGraphKey && !e.metaKey) {
                // straight forward click - select this item only
                // ...unless this item is already selected (or part of a larger selection), in which case don't change anything...
                if (!selection.isSelected(items[this_item])) {
                    // not currently selected - select it!
                    selection.solo(items[this_item])
                }
            } else if (e.shiftKey && !e.ctrlKey && !e.altKey && !e.altGraphKey && !e.metaKey) {
                // shift-click - add this item to the selection (if not already selected!)
                selection.add(items[this_item])
            } else if (!e.shiftKey && e.ctrlKey && !e.altKey && !e.altGraphKey && !e.metaKey) {
                // control-click - toggle this item 'selected' state
                // is this item already selected..?
                if (selection.isSelected(items[this_item])) {
                    // yes - remove it from the list!
                    selection.remove(items[this_item]);
                } else {
                    // no - add it to the list!
                    selection.add(items[this_item]);
                }
            } else {
                // some other form of click... do nothing..?
            }
        }
  
        // update canvas
        draw();
        // update mouse pointer
        setCursorStyle(this_item,pos);
    } else {
        // right-click (or maybe middle-click?)
    }
}

// This gets called just after a mouse up event - regardless of whether there's been any mouse movment... (on Chrome on my Chromebook)
function canvasClick(e) {
    // currently, all the code that was here is now in MouseDown, above... 
}

// This gets called when the user double clicks with a mouse (or on a touch screen..?)
// When the user double clicks with a mouse, we receive one Click event for the first click, then a second Click event followed by a DoubleClick event for the second click
function canvasDoubleClick(e) {
    var pos = getCursorPosition(e);

    // try to work out if we have clicked on an existing item or not...
    var this_item = which_item(pos)

    if (this_item == -1) {
        // double click not on an item - add a new circle to our items list, where we clicked...
        // add it to the list, and update this_item to point at it
        // (updating this_item is mainly for the benefit of the call to setCursor below, and rather assumes that we've inserted our new item somewhere underneath the mouse cursor...)
        this_item = items.add(new Circle(pos.x, pos.y, 10+Math.floor(Math.random()*11)));
    } else {
        // we've double clicked on an item...
        // erm... do nothing for now..? - nope!
        
        // select only this item
        selection.solo(items[this_item])
    }
    
    // prevent default actions for a double click (tends to highlight some text around the canvas!..)
    e.preventDefault();
    // doesn't seem to be working..?

    // update canvas
    draw();
    // update mouse pointer
    setCursorStyle(this_item,pos);
}

function which_item(pos) {
    for (var i = items.length-1; i >= 0 ; i--) {
        if (items[i].mouseOver(pos)) return i;
    }
    return -1;
}

function canvasMouseMove(e) {
    var pos = getCursorPosition(e);

    // try to work out if we are over an existing item or not...
    setCursorStyle(which_item(pos), pos);
}

function setCursorStyle(it, pos) {
    if (it == -1) {
        // not over any existing items
		canvasElement.style.cursor = "default";
    } else {
        // over an item
        var cursor;
        try {
            cursor = items[it].getCursorStyle(pos);
        } catch(err) {
            // most probably wind up here because this item doesn't have a getCursor method defined...
            // in which case, this isn't strictly necessary.  But I'm leaving it here in case getCursor throws some kind of error itself (which I guess could leave cursor as, say, null or "" or "ldkfhgld"..?)
            cursor = undefined;
        }
        if (cursor === undefined) cursor = items[it].cursorStyle;
        if (cursor === undefined) cursor = "default";
        canvasElement.style.cursor = cursor;
    }
}

function canvasKeyDown(e) {
    // if we want to prevent the Backspace button from moving us to the previous page in the browser history, then we need to catch the KeyDown event (for e.keyIdentifier = "U+0008") and run e.preventDefault()
    // - the move to the previous page normally happens on the key down event, so if we wait for the key up event it'll be too late!.. (in Chrome, on my Chromebook, at least...)
    switch (e.keyIdentifier) {
    case "U+007F": // Delete (alt-backspace)
    case "U+0008": // Backspace
        if (selection.any()) {
            // one or more items selected - delete them!
            for (var i = items.length; --i >= 0 ; ) {
                if (selection.isSelected(items[i])) {
                    items.removeByIndex(i);
                }
            }
            selection.clear();
            e.preventDefault();
            draw();
        }
        break;
    case "U+0041": // A
        if (e.ctrlKey && !e.shiftKey && !e.altKey && !e.altGraphKey && !e.metaKey) {
            // Ctrl-A - select all items!
            selection.addAll();
            e.preventDefault();
            draw();
        } else {
            // do nothing..?
        }
    }

}

function draw() {
    // start from scratch - clear the whole canvas
    drawingContext.clearRect(0, 0, canvasWidth, canvasHeight);

    // draw our background
    var gradient = drawingContext.createLinearGradient(0, 0, canvasWidth, canvasHeight);
    gradient.addColorStop(0, "#d0d0d0");
    gradient.addColorStop(1, "#fbfbfb");
    // gradient.addColorStop(0, "#ff0000");
    // gradient.addColorStop(0.25, "#ffff00");
    // gradient.addColorStop(0.5, "#00ff00");
    // gradient.addColorStop(0.75, "#00ffff");
    // gradient.addColorStop(1, "#0000ff");
    drawingContext.fillStyle = gradient;
    // drawingContext.fillStyle = "#eee";
    drawingContext.fillRect(0, 0, canvasWidth, canvasHeight)

    for (var i = 0; i < items.length; i++) {
	    // drawItem(items[i]);
        items[i].draw();
    }

    counterElement.innerHTML = items.length;
    nextIdElement.innerHTML = items.nextItemId;
}

function init(canvas, counter, nextId) {
    // check if canvas already exists in the html document, and create one if not
    if (!canvas) {
        canvas = document.createElement("canvas");
    	canvas.id = "canvas";
    	document.body.appendChild(canvas);
    }
    canvasElement = canvas;
    // set the height and width of out canvas
    canvasElement.width = canvasWidth;
    canvasElement.height = canvasHeight;
    canvasElement.tabIndex = 1;
    // get the drawign context for the canvas
    drawingContext = canvasElement.getContext("2d");

    // listen out for clicks
    canvasElement.addEventListener("click", canvasClick, false);
    // listen out for double-clicks
    canvasElement.addEventListener("dblclick", canvasDoubleClick, false);
    // listen out for select events (like double-clicking...)
    canvasElement.addEventListener("mousedown", canvasMouseDown, false);
    // ... and for mouse moves
    canvasElement.addEventListener("mousemove", canvasMouseMove, false);
    // ... and for key-down events
    // note: the canvas element doesn't take the input focus when clicked on, so therefore it doesn't receive any key events
    // document.body.addEventListener("keydown", bodyKeyDown, false);
    // okay, if you give the canvas element a tabindex, then it can and will take the input focus!..
    // (this information found here: http://stackoverflow.com/a/57332)
    canvasElement.addEventListener("keydown", canvasKeyDown, false);

    // check if a counter already exists in the html document, and create one if not
    if (!counter) {
        counter = document.createElement("p");
	    document.body.appendChild(counter);
    }
    counterElement = counter;

    // check if a 'next id' already exists in the html document, and create one if not
    if (!nextId) {
        nextId = document.createElement("p");
	    document.body.appendChild(nextId);
    }
    nextIdElement = nextId;

    // set up a bunch of random circles...
    for (var i = 0; i < 0; i++) {
        items.add(new Circle(Math.floor(Math.random() * canvasWidth), Math.floor(Math.random() * canvasHeight), 10+Math.floor(Math.random()*11)));
    }
  
    // do an initial drawing of our (blank?) canvas
    draw();
}
 </script>
 <title>Canvas 6</title>
</head>
<body>
 <h1>Canvas Development #6</h1>
 <p>Double-click anywhere in the square to draw a circle!</p>
 <div style="float: left; height: 320px; width: 315px; overflow: auto;">
  <!-- use "overflow: scroll;" to make scroll bars always visible -->
  <!-- It looks like, in Chrome on my Chromebook, the width of the parent div needs to be at least 15px greater than the canvas, and the height at least 20px greater, for the scroll bars to deactivate -->
  <canvas id="myCanvas" width="100" height="100"></canvas>
 </div>
 <p>Number of items: <span id="counter">-1</span><br />
    Next unique item id: <span id="nextId">-1</span><br />
    Click on a circle to select it, shift-click to add to your selection, or control-click to toggle selection.<br />
    Press backsapce/delete to delete selected circles!<br />
    (note: if nothing is selected, then backspace will do it's default action, which is to go to the previous page in your browser's history...)<br />
    (also note: the canvas needs to have the input focus (shown by a blue halo) to catch any keyboard events)<br />
    Ctrl-A will select all circles.<br />
    Internally, started change towards a more 'object-oriented' approach... (circles are more object-y; so is the selection list; and the list of items)<br />
    Double-clicking now supported - double click to create a circle, and double-click on a circle to select only it!
 </p>
 <script>
   init(document.getElementById('myCanvas'), document.getElementById('counter'), document.getElementById('nextId'));
 </script>
</body>
</html>