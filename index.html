<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <script>

//3456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 1234567890

    // default values
    var gridSize = 10;
    var canvasWidth = 300;
    var canvasHeight = 300;
    
    // references to items in the HTML DOM
    var canvasElement;
    var drawingContext;
    var counterElement;
    var nextIdElement;
    var thisIdElement;
    
    // global variables
    // 'items' Object, containing all our items, refernced by unique id numbers
    var items = new function() {
    // I use...
    // items[index] to get at a specific item
    // (and items[index].xxx to get at that items properties...)
    // items.push(item) to add an item
    //   - change to use items.add(item) instead
    // items.splice(index, 1) to remove an item
    //   - change to use items.remove(item) instead
    // items.length to get number of items
    //   - change to use items.count() instead
    // for loop to check through all items
    //   - mainly this is for drawing the items (so can loop through stacking order instead), or
    //     working out if we are hovering over an item (loop through stacking order instead), or
    //     selecting all items (could do this by looping through stacking order, althrough that's
    //     less scemantically pleasing...)
    //   note, we should use "for (var i = items.length; --i >= 0 ; ) {" as (apparently) it is the
    //   fastest way of going through the array.  "for (var i in items) {" shouldn't really be used
    //   on an array, as it can throw up additional 'methods' and things...  see here:
    //   http://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-such-a-bad-idea
    // items = [] to intialise it, once - now moved from init function to initial declaration here
    //
    // Hmm.. okay, here's an idea - seperate the display order (or stacking order) out into a
    // separate array of itemId's.  Then change items into an object, with the itemId being the key
    // of each Item - these can be accessed as items[itemId].
    // Pros - easier direct access to items by their itemId - will be useful in the future
    //      - stacking order becomes an array of itemId's - with 'methods' for re-ordering items
    // Cons - less easy to iterate through all items - using "for (var item in items) {" would also
    //        pick up on other 'methods' and variables within the items object...
    //      - when we delete an item we'd ought to update the stacking order array too (or does it
    //        tidy itself up / fail gracefully when it finds an item that no longer exists..?)
    //         - will need to think about this also for other things that might reference items by
    //           their itemId - like a line linking two items together...
        this.nextItemId = 0
        this.length = 0
        this.listOfIds = {}
        this.add = function(item) {
            item.id = this.nextItemId++
            this[item.id] = item
            this.listOfIds[item.id] = item.id
            stack.add(item.id)
            this.length++
            return item.id
        }
        this.remove = function(id) {
            stack.remove(id)
            delete this[id]
            delete this.listOfIds[id]
            return this.length--
        }
        this.count = function() {
            return this.length
        }
        this.get = function(id) {
            return this[id]
        }
        this.getAllIds = function() {
            return this.listOfIds
        }
    }

    // 'stack' Object, for keeping track of the order in which items are to be displayed
    // this object should be intrinsically tied with the list of items - every item should appear
    //   once, and only once, in the stack...
    // it would be great to turn this into more of a 'tree' like object...
    //   - individual nodes for individual items
    //   - branches for grouped items
    //   - branches for 'compound' items
    //      (similar to grouped items, but the user cannot ungroup them)
    // note: we could 'hide' item by removing them from the stack...  might be better to give them
    //   a 'hidden' flag to prevent them being drawn - this way they'll remember their position in
    //   the stack whilst hidden.  Would also be easier to find hidden items and therefore unhide
    //   them!..
    var stack = new function() {
        this.list = []
        this.count = function() {
            return this.list.length
        }
        this.add = function(id) {
            var index = this.list.indexOf(id)
            if (index == -1) {
                return (this.list.push(id) - 1)
            } else {
                // don't add item a second time!..
                return index
            }
        }
        this.remove = function(id) {
            var index = this.list.indexOf(id)
            if (index != -1) {
                this.list.splice(index, 1)
            }
            return index
        }
        this.get = function(index) {
            return this.list[index]
        }
    }

    // 'selection' Object, for keeping track of which items are currently selected
    var selection = new function() {
        this.list = []
        this.colour = null
        this.line_colour = "#ff0000"
        this.count = function() {
            return this.list.length
        }
        this.any = function() {
            return (this.list.length > 0)
        }
        this.clear = function() {
            this.list = []
            return true
        }
        this.add = function(item) {
            var index = this.list.indexOf(item.id)
            if (index == -1) {
                return (this.list.push(item.id) - 1)
            } else {
                // don't add item a second time!..
                return index
            }
        }
        this.solo = function(item) {
            this.list = [item.id]
            return 0
        }
        this.remove = function(item) {
            var index = this.list.indexOf(item.id)
            if (index != -1) {
                this.list.splice(index, 1)
            }
            return index
        }
        this.isSelected = function(item) {
            return (this.list.indexOf(item.id) != -1)
        }
        this.addAll = function() {
            this.list = []
            var allIds = items.getAllIds()
            for (var id in allIds) {
                this.list.push(allIds[id])
            }
            return true
        }
        this.get = function(index) {
            return this.list[index]
        }
    }

/************************\
* Shape item definitions *
\************************/

function Item() {
}
// Set up the Item prototype.
// I think we are unlikely to create any Items, but we will set this as the __proto__ for other
//   item types, so that we can inherit (default) functions and values from Item

// Can define a single property like this:
// Item.prototype.test = function () {
//     return (1 == 1)
// }

// Can define multiple properties like this:
// Item.prototype = {
//     // note: we are completely replacing the prototype by doing this, so ought to preserve the
//     //   constructor property
//     // note: also, this method makes all additional properties - and the constructor - enumerable...
//     constructor: Item,
//     test: function() {
//         return (1 == 1)
//     }
// }

// Could also define a single property, with control of various flags, like this:
// Object.defineProperty(Item, "test", {
//     // note: all three of these flags default to false
//     // note: however, these flags are contained within an object, so in theory we could inherit
//     //   different 'default' values from the Object.prototype
//     // enumerable: if true, this property will show up during a "for (x in y)" loop
//     enumerable: false,
//     // configurable: if true, this property can be deleted, and have its type changed
//     configurable: false,
//     // writable: if true, the value of this property can be changed with an assignment operator
//     writable: false,
//     // value: the value of the property! can be any valid Javascript value (number, object,
//     //   function, etc)
//     value: function() {
//         return (1 == 1)
//     }
// });
// see here for more details:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#summary

Object.defineProperty(Item.prototype, "draw", {
    enumerable: false, configurable: false, writable: false,
    value: function (context, colour, line_colour) {
        switch (arguments.length) {
            case 0:  context = drawingContext
            case 1:  colour = this.colour
            case 2:  line_colour = this.line_colour
        }
        if (selection.isSelected(this)) {
            // item is selected
            if (selection.colour) colour = selection.colour
            if (selection.line_colour) line_colour = selection.line_colour
        }
        
        // not sure what to draw for a 'default' here... maybe a small cross, or something..?
    }
});

Object.defineProperty(Item.prototype, "mouseOver", {
    enumerable: false, configurable: false, writable: false,
    value: function(pos) {
        return ( (this.x == pos.x) & (this.y == pos.y) )
    }
});


function Rectangle(x, y, width, height, colour, line_width, line_colour) {
    // deal with default values for any missing arguments...
    // (borrowed from here: http://stackoverflow.com/a/9363769)
    switch (arguments.length) {
        case 2:  width = 10;
        case 3:  height = 10;
        case 4:  colour="#fff";
        case 5:  line_width=3;
        case 6:  line_colour="#777";
    }
    // this.type = "rectangle";
    // this.id = newItemId++;
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.colour = colour;
    this.line_width = line_width;
    this.line_colour = line_colour;

    this.draw = function (context, colour) {
        switch (arguments.length) {
            case 0:  context = drawingContext;
            case 1:  colour = this.colour;
        }
    }
}
// Rectangle.prototype = Item

function Circle(x, y, width, height, colour, line_width, line_colour) {
    // deal with default values for any missing arguments...
    // (borrowed from here: http://stackoverflow.com/a/9363769)
    switch (arguments.length) {
        case 2:  width = 10;
        case 3:  height = 10;
        case 4:  colour="#fff";
        case 5:  line_width=3;
        case 6:  line_colour="#777";
    }
    // this.type = "circle";
    //  could instead use items[id].constructor.name (which gives "Circle")
    //  or items[id].constructior == Circle to see if an item is a Circle
    // this.id = newItemId++;
    //  now the id is initialised by items.add()...
    this.x = x;
    this.y = y;
    this.radius = this.width = width;
    this.height = height;
    this.colour = colour;
    this.line_width = line_width;
    this.line_colour = line_colour;
    this.cursorStyle = "pointer";

//    this.draw = function (context, colour, line_colour) {
//        switch (arguments.length) {
//            case 0:  context = drawingContext;
//            case 1:  colour = this.colour;
//            case 2:  if (selection.isSelected(this)) {
//                         // item is selected
//                         line_colour = "#ff0000";
//                     } else {
//                         // item not currently selected
//                         line_colour = this.line_colour;
//                     }
//        }
//        
//        context.beginPath();
//        context.arc(this.x, this.y, this.radius, 0, Math.PI*2, false);
//        context.closePath();
//        
//        context.fillStyle = colour;
//	    context.fill();
//        
//        context.strokeStyle = line_colour;
//        context.lineWidth = this.line_width;
//        context.stroke();
//    }
    
//    this.mouseOver = function(pos) {
        // var x2 = Math.pow(this.x - pos.x,2);
        // var y2 = Math.pow(this.y - pos.y,2);
        // var r = Math.sqrt(x2 + y2);
//        return ( (Math.pow(this.x - pos.x,2) + Math.pow(this.y - pos.y,2)) <= Math.pow(this.radius,2) );
//    }
}

Circle.prototype = Object.create(Item.prototype)
// Circle.prototype.constructor = Circle
// this is how we are supposed to do 'classical inheritance' - see here:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create#Classical_inheritance_with_Object.create
Object.defineProperty(Circle.prototype, "constructor", {enumerable: false, configurable: false, writable: false, value: Circle})

// add some 'methods' to our genreal Circle.prototype
// this (I think) means that we only really have one instance of each function - it just gets called
//   with a different 'this' depending on which Circle is using it
//   (as apposed to defining them within the creator function above, in which case each new Circle
//   creates its own instance of each function - which must use more resources, surely..?)
// this also means we can make functions non-enumerable - probably less useful for Circles and the
//   like, but may be useful for other things...
Object.defineProperty(Circle.prototype, "draw", {
    enumerable: false, configurable: false, writable: false,
    value: function (context, colour, line_colour) {
        switch (arguments.length) {
            case 0:  context = drawingContext;
            case 1:  colour = this.colour;
            case 2:  line_colour = this.line_colour;
        }
        if (selection.isSelected(this)) {
            // item is selected
            if (selection.colour) colour = selection.colour;
            if (selection.line_colour) line_colour = selection.line_colour;
        }
        
        context.beginPath();
        context.arc(this.x, this.y, this.radius, 0, Math.PI*2, false);
        context.closePath();
        
        context.fillStyle = colour;
	    context.fill();
        
        context.strokeStyle = line_colour;
        context.lineWidth = this.line_width;
        context.stroke();
    }
});

Object.defineProperty(Circle.prototype, "mouseOver", {
    enumerable: false, configurable: false, writable: false,
    value: function(pos) {
        // var x2 = Math.pow(this.x - pos.x,2);
        // var y2 = Math.pow(this.y - pos.y,2);
        // var r = Math.sqrt(x2 + y2);
        return ( (Math.pow(this.x - pos.x,2) + Math.pow(this.y - pos.y,2)) <= Math.pow(this.radius,2) );
    }
});



function Position(x, y) {
    this.x = x;
    this.y = y;
}

function getCursorPosition(e) {
    /* returns Position with .x and .y properties */
    var x;
    var y;
    if (e.pageX != undefined && e.pageY != undefined) {
        x = e.pageX;
        y = e.pageY;
    } else {
        x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
        y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
    }
    x -= canvasElement.offsetLeft;
    y -= canvasElement.offsetTop;

    var pos = new Position(x, y);
    return pos;
}



/****************\
* Event handlers *
\****************/

// Mouse Click Events sequence:
// 1) MouseDown
// 2) MouseUp
// 3) Click
//
// 4) MouseDown
// 5) MouseUp
// 6) Click
// 7) DoubleClick
//
// Because the browser considers the canvas to be one element (it doesn't know about our 'items'),
// we tend to receive most of these even if the mouse moves about a bit between the MouseDown and
// MouseUp.  If the MouseDown happens outside the canvas, but the MouseUp happens within the canvas,
// then we don't get a Click after the MouseUp.  Pressing Escape between MouseDown and MouseUp
// doesn't appear to cancel the Click.  Doesn't seem to matter how long the pause between the
// MouseDown and MouseUp - we still get a Click.


function canvasMouseDown(e) {
    // button detection needs improving, espeically if this is ever to become cross-browser compatible!.. see here:
    // http://javascript.info/tutorial/mouse-events#getting-the-button-info-which-button
    // or here:
    // http://www.quirksmode.org/js/events_properties.html#button
    if (e.button == 0) {
        // normal left-click
        
        // prevent default actions - in particular for a double click (tends to highlight some text around the canvas!..)
        e.preventDefault();
        // unfortunately this also prevents the canvas from getting the focus when we click on it, which prevents us from receiving KeyDown events...
        // see here for methods to work out if our convas has the focus at the moment (not straight forward!): http://www.whatwg.org/specs/web-apps/current-work/#focus-management-apis
        if ( !(document.hasFocus() && (document.activeElement == canvasElement)) ) {
            // Now, 'manually' pulling focus to the canvas like this seems to move the window around (which I don't really want), so...
            // (window.scrollX and .scrollY don't seem to work..? although they should do! see here:
            // https://developer.mozilla.org/en-US/docs/Web/API/window.scrollY
            // and here:
            // http://stackoverflow.com/questions/3791336/why-were-window-scrolly-and-window-scrollx-introduced )
            // var scroll_x = window.pageXOffset;
            // var scroll_y = window.pageYOffset;
            // This is more robust across various browsers...
            var scroll_x = (window.pageXOffset !== undefined) ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;
            var scroll_y = (window.pageYOffset !== undefined) ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
            canvasElement.focus();
            window.scroll(scroll_x,scroll_y);
        }
        var pos = getCursorPosition(e);
        
        // try to work out if we have clicked on an existing item or not...
        var this_item = which_item(pos)
        
        if (this_item == -1) {
            // we've clicked in empty space...
            if (selection.any()) {
                // one or more items currently selected - unselect everything
                selection.clear();
            } else {
                // nothing currently selected - do nothing for now..?
            }
        } else {
            // we've clicked on an item...
            
            if (!e.shiftKey && !e.ctrlKey && !e.altKey && !e.altGraphKey && !e.metaKey) {
                // straight forward click - select this item only
                // ...unless this item is already selected (or part of a larger selection), in which case don't change anything...
                if (!selection.isSelected(items[this_item])) {
                    // not currently selected - select it!
                    selection.solo(items[this_item])
                }
            } else if (e.shiftKey && !e.ctrlKey && !e.altKey && !e.altGraphKey && !e.metaKey) {
                // shift-click - add this item to the selection (if not already selected!)
                selection.add(items[this_item])
            } else if (!e.shiftKey && e.ctrlKey && !e.altKey && !e.altGraphKey && !e.metaKey) {
                // control-click - toggle this item 'selected' state
                // is this item already selected..?
                if (selection.isSelected(items[this_item])) {
                    // yes - remove it from the list!
                    selection.remove(items[this_item]);
                } else {
                    // no - add it to the list!
                    selection.add(items[this_item]);
                }
            } else {
                // some other form of click... do nothing..?
            }
        }
  
        // update canvas
        draw();
        // update mouse pointer
        setCursorStyle(this_item,pos);
    } else {
        // right-click (or maybe middle-click?)
    }
}

// This gets called just after a mouse up event - regardless of whether there's been any mouse movment... (on Chrome on my Chromebook)
function canvasClick(e) {
    // currently, all the code that was here is now in MouseDown, above... 
}

// This gets called when the user double clicks with a mouse (or on a touch screen..?)
// When the user double clicks with a mouse, we receive one Click event for the first click, then a second Click event followed by a DoubleClick event for the second click
function canvasDoubleClick(e) {
    var pos = getCursorPosition(e);

    // try to work out if we have clicked on an existing item or not...
    var this_item = which_item(pos)

    if (this_item == -1) {
        // double click not on an item - add a new circle to our items list, where we clicked...
        // add it to the list, and update this_item to point at it
        // (updating this_item is mainly for the benefit of the call to setCursor below, and rather assumes that we've inserted our new item somewhere underneath the mouse cursor...)
        this_item = items.add(new Circle(pos.x, pos.y, 10+Math.floor(Math.random()*11)));
    } else {
        // we've double clicked on an item...
        // erm... do nothing for now..? - nope!
        
        // select only this item
        selection.solo(items[this_item])
    }
    
    // prevent default actions for a double click (tends to highlight some text around the canvas!..)
    e.preventDefault();
    // doesn't seem to be working..?

    // update canvas
    draw();
    // update mouse pointer
    setCursorStyle(this_item,pos);
}

// go through all the items (in reverse stacking order) to see which, if any, we are over
function which_item(pos) {
    for (var index = stack.count(); --index>=0; ) {
        if (items[stack.get(index)].mouseOver(pos)) return stack.get(index);
    }
    return -1;
}

function canvasMouseMove(e) {
    var pos = getCursorPosition(e);
    var itemId = which_item(pos)
    // try to work out if we are over an existing item or not...
    setCursorStyle(itemId, pos);

    thisIdElement.innerHTML = itemId;
}

function setCursorStyle(id, pos) {
    if (id == -1) {
        // not over any existing items
		canvasElement.style.cursor = "default";
    } else {
        // over an item
        var cursor;
        if (items[id].getCursorStyle !== undefined) cursor = items[id].getCursorStyle(pos);
        if (cursor === undefined) cursor = items[id].cursorStyle;
        if (cursor === undefined) cursor = "default";
        canvasElement.style.cursor = cursor;
    }
}

function canvasKeyDown(e) {
    // if we want to prevent the Backspace button from moving us to the previous page in the browser history, then we need to catch the KeyDown event (for e.keyIdentifier = "U+0008") and run e.preventDefault()
    // - the move to the previous page normally happens on the key down event, so if we wait for the key up event it'll be too late!.. (in Chrome, on my Chromebook, at least...)
    switch (e.keyIdentifier) {
    case "U+007F": // Delete (alt-backspace)
    case "U+0008": // Backspace
        if (selection.any()) {
            // one or more items selected - delete them!
            for (var index = selection.count(); --index>=0; ) {
                items.remove(selection.get(index));
            }
            selection.clear();
            e.preventDefault();
            draw();
        }
        break;
    case "U+0041": // A
        if (e.ctrlKey && !e.shiftKey && !e.altKey && !e.altGraphKey && !e.metaKey) {
            // Ctrl-A - select all items!
            selection.addAll();
            e.preventDefault();
            draw();
        } else {
            // do nothing..?
        }
    }

}

function draw() {
    // start from scratch - clear the whole canvas
    drawingContext.clearRect(0, 0, canvasWidth, canvasHeight);

    // draw our background
    var gradient = drawingContext.createLinearGradient(0, 0, canvasWidth, canvasHeight);
    gradient.addColorStop(0, "#d0d0d0");
    gradient.addColorStop(1, "#fbfbfb");
    // gradient.addColorStop(0, "#ff0000");
    // gradient.addColorStop(0.25, "#ffff00");
    // gradient.addColorStop(0.5, "#00ff00");
    // gradient.addColorStop(0.75, "#00ffff");
    // gradient.addColorStop(1, "#0000ff");
    drawingContext.fillStyle = gradient;
    // drawingContext.fillStyle = "#eee";
    drawingContext.fillRect(0, 0, canvasWidth, canvasHeight)

    var count = stack.count()
    for (var index = 0; index<count; index++) {
	    // drawItem(items[i]);
        items[stack.get(index)].draw();
    }

    counterElement.innerHTML = items.length;
    nextIdElement.innerHTML = items.nextItemId;
}

function init(canvas, counter, nextId) {
    // check if canvas already exists in the html document, and create one if not
    if (!canvas) {
        canvas = document.createElement("canvas");
    	canvas.id = "canvas";
    	document.body.appendChild(canvas);
    }
    canvasElement = canvas;
    // set the height and width of out canvas
    canvasElement.width = canvasWidth;
    canvasElement.height = canvasHeight;
    canvasElement.tabIndex = 1;
    // get the drawign context for the canvas
    drawingContext = canvasElement.getContext("2d");

    // listen out for clicks
    canvasElement.addEventListener("click", canvasClick, false);
    // listen out for double-clicks
    canvasElement.addEventListener("dblclick", canvasDoubleClick, false);
    // listen out for select events (like double-clicking...)
    canvasElement.addEventListener("mousedown", canvasMouseDown, false);
    // ... and for mouse moves
    canvasElement.addEventListener("mousemove", canvasMouseMove, false);
    // ... and for key-down events
    // note: the canvas element doesn't take the input focus when clicked on, so therefore it doesn't receive any key events
    // document.body.addEventListener("keydown", bodyKeyDown, false);
    // okay, if you give the canvas element a tabindex, then it can and will take the input focus!..
    // (this information found here: http://stackoverflow.com/a/57332)
    canvasElement.addEventListener("keydown", canvasKeyDown, false);

    // check if a counter already exists in the html document, and create one if not
    if (!counter) {
        counter = document.createElement("p");
	    document.body.appendChild(counter);
    }
    counterElement = counter;

    // check if a 'next id' already exists in the html document, and create one if not
    if (!nextId) {
        nextId = document.createElement("p");
	    document.body.appendChild(nextId);
    }
    nextIdElement = nextId;

    // check if a 'next id' already exists in the html document, and create one if not
    thisIdElement = document.getElementById('thisId');
    if (!thisId) {
        thisIdElement = document.createElement("p");
	    document.body.appendChild(thisIdElement);
    }

    // set up a bunch of random circles...
    for (var i = 0; i < 5; i++) {
        items.add(new Circle(Math.floor(Math.random() * canvasWidth), Math.floor(Math.random() * canvasHeight), 10+Math.floor(Math.random()*11)));
    }
  
    // do an initial drawing of our (blank?) canvas
    draw();
}
 </script>
 <title>Canvas 7</title>
</head>
<body>
 <h1>Canvas Development #7</h1>
 <p>Double-click anywhere in the square to draw a circle!</p>
 <div style="float: left; height: 320px; width: 315px; overflow: auto;">
  <!-- use "overflow: scroll;" to make scroll bars always visible -->
  <!-- It looks like, in Chrome on my Chromebook, the width of the parent div needs to be at least 15px greater than the canvas, and the height at least 20px greater, for the scroll bars to deactivate -->
  <canvas id="myCanvas" width="100" height="100"></canvas>
 </div>
 <p>Number of items: <span id="counter">-1</span><br />
    Next unique item id: <span id="nextId">-1</span><br />
    This item id: <span id="thisId">-1</span><br />
    Click on a circle to select it, shift-click to add to your selection, or control-click to toggle selection.<br />
    Press backsapce/delete to delete selected circles!<br />
    (note: if nothing is selected, then backspace will do it's default action, which is to go to the previous page in your browser's history...)<br />
    (also note: the canvas needs to have the input focus (shown by a blue halo) to catch any keyboard events)<br />
    Ctrl-A will select all circles.<br />
    Internally, started change towards a more 'object-oriented' approach... (circles are more object-y; so is the selection list; and the list of items)<br />
    Double-clicking now supported - double click to create a circle, and double-click on a circle to select only it!<br />
    Internally separated out the stacking order from the list of items - hopefully a useful move in the future!..<br />
    Also started making more use of prototypes... Circles now inherit from a new Item type, and generic Circle functions are contained in the Circle.prototype, rather than in each Circle instance individually (I think this is an efficient move..?)
 </p>
 <script>
   init(document.getElementById('myCanvas'), document.getElementById('counter'), document.getElementById('nextId'));
 </script>
</body>
</html>