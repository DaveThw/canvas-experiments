<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <script>

//3456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 1234567890

function breakpoint() {
    // Set a breakpoint here to pause Javascript!..
    // (I've put this at the top of the script, so that it won't move around as we add/remove lines)
    var test = true;
}

    // default values
    var gridSize = 10;
    var canvasWidth = 300;
    var canvasHeight = 300;
    
    // references to items in the HTML DOM
    var canvasElement;
    var drawingContext;
    var counterElement;
    var nextIdElement;
    var thisIdElement;
    
    var timings = [ {label: "init", time: new Date().getTime()} ];
    defObjProp(timings, "add", function (label) {
        //var thisTime = new Date().getTime()
        //var lastTime = timings[timings.length-1].time
        //var delay = thisTime - lastTime
        //if (label) this.push({label: label, time: thisTime, delay: delay})
        //else this.push({time: thisTime, delay: delay})
    } )


// to make life a little easier, here's a function to add a property (with optional flags) to an
// object
function defObjProp(obj, prop, val, writ, enu, conf) {
    switch (arguments.length) {
        case 2:  val = undefined
        case 3:  writ = false
        case 4:  enu = false
        case 5:  conf = false
    }
    var def = defObjProp.def || ( defObjProp.def = {} )
    def.value = val
    def.enumerable = enu
    def.writable = writ
    def.configurable = conf
    Object.defineProperty(obj, prop, def)
}

// this is how we are supposed to do 'classical inheritance' - see here:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create#Classical_inheritance_with_Object.create
// but to make life a little easier, here's a function to do it for us.
function setObjProto(obj, proto) {
    obj.prototype = Object.create(proto.prototype)
    // obj.prototype.constructor = obj
    defObjProp(obj.prototype, "constructor", obj)
}

// and finally (for now) in the making-life-a-little-easier group of functions, here's one to call
// the parent constructor, from within a constructor function for which we set the parent prototype
// to something specific - for example by calling setObjProto above!..
function callParentConstructor(me) {
    // Object.getPrototypeOf(Object.getPrototypeOf(me)).constructor.call(me)
    var that = Object.getPrototypeOf(me)
    // so here, 'that' is the prototype of the thing that called this function
    if (that !== Object) {
        that = Object.getPrototypeOf(that)
        // now, 'that' is the prototype of the parent of the thing that called this function
        if (that !== Object) {
            that.constructor.call(me)
        }
    }
}




/**************************************************************************************************\
*                                   Master structure definitions                                   *
\**************************************************************************************************/


// 'items' Object, containing all our items, referenced by unique id numbers
// I use...
// items[id] to get at a specific item
// (and items[id].xxx to get at that items properties...)
// items.push(item) to add an item
//   - change to use items.add(item) instead
// items.splice(index, 1) to remove an item
//   - change to use items.remove(item) instead
// items.length to get number of items
//   - could change to use items.count() instead..?
// for loop to check through all items
//   - mainly this is for drawing the items (so can loop through stacking order instead), or
//     working out if we are hovering over an item (loop through stacking order instead), or
//     selecting all items (could do this by looping through stacking order, although that's
//     less scemantically pleasing...)
//   note, we should use "for (var i = items.length; --i >= 0 ; ) {" as (apparently) it is the
//   fastest way of going through the array.  "for (var i in items) {" shouldn't really be used
//   on an array, as it can throw up additional 'methods' and things...  see here:
//   http://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-such-a-bad-idea
// items = [] to intialise it, once - now moved from init function to initial declaration here
//
// Hmm.. okay, here's an idea - seperate the display order (or stacking order) out into a
// separate array of itemId's.  Then change items into an object, with the itemId being the key
// of each Item - these can be accessed as items[itemId].
// Pros - easier direct access to items by their itemId - will be useful in the future
//      - stacking order becomes an array of itemId's - with 'methods' for re-ordering items
// Cons - less easy to iterate through all items - using "for (var item in items) {" would also
//        pick up on other 'methods' and variables within the items object...
//      - when we delete an item we'd ought to update the stacking order array too (or does it
//        tidy itself up / fail gracefully when it finds an item that no longer exists..?)
//         - will need to think about this also for other things that might reference items by
//           their itemId - like a line linking two items together...
// Done! - although more work on this idea still to be done...
function listOfItems() {
    defObjProp(this, "nextItemId", 0, true)
    defObjProp(this, "length", 0, true)
}
defObjProp(listOfItems.prototype, "add", function(item) {
    item.id = this.nextItemId++
    this[item.id] = item
    stack.add(item.id)
    this.length++
    return item.id
} )
defObjProp(listOfItems.prototype, "remove", function(id) {
    stack.remove(id)
    if (this[id] != undefined) {
        delete this[id]
        return this.length--
    } else {
        return this.length
    }
} )
defObjProp(listOfItems.prototype, "removeItem", function(item) {
    return this.remove(item.id)
} )
defObjProp(listOfItems.prototype, "count", function() {
    return this.length
} )

var items = new listOfItems()


// 'stack' Object, for keeping track of the order in which items are to be displayed
// this object should be intrinsically tied with the list of items - every item should appear
//   once, and only once, in the stack...
// it would be great to turn this into more of a 'tree' like object...
//   - individual nodes for individual items
//   - branches for grouped items
//   - branches for 'compound' items
//      (similar to grouped items, but the user cannot ungroup them)
// note: we could 'hide' item by removing them from the stack...  might be better to give them
//   a 'hidden' flag to prevent them being drawn - this way they'll remember their position in
//   the stack whilst hidden.  Would also be easier to find hidden items and therefore unhide
//   them!..
var stack = new function() {
    this.list = []
    this.count = function() {
        return this.list.length
    }
    this.add = function(id) {
        var index = this.list.indexOf(id)
        if (index == -1) {
            return (this.list.push(id) - 1)
        } else {
            // don't add item a second time!..
            return index
        }
    }
    this.remove = function(id) {
        var index = this.list.indexOf(id)
        if (index != -1) {
            this.list.splice(index, 1)
        }
        return index
    }
    this.get = function(index) {
        return this.list[index]
    }
}

// 'selection' Object, for keeping track of which items are currently selected
var selection = new function() {
    this.list = []
    this.colour = null
    this.line_colour = "#ff0000"
    this.count = function() {
        return this.list.length
    }
    this.any = function() {
        return (this.list.length > 0)
    }
    this.clear = function() {
        for (var index = this.list.length; --index>=0; ) {
            items[this.list[index]].selected = false
        }
        this.list = []
        return true
    }
    this.delete = function() {
        for (var index = this.list.length; --index>=0; ) {
            items.remove(this.list[index])
        }
        this.list = []
        return true
    }
    this.add = function(item) {
        item.selected = true
        var index = this.list.indexOf(item.id)
        if (index == -1) {
            return (this.list.push(item.id) - 1)
        } else {
            // don't add item a second time!..
            return index
        }
    }
    this.solo = function(item) {
        for (var index = this.list.length; --index>=0; ) {
            items[this.list[index]].selected = false
        }
        item.selected = true
        this.list = [item.id]
        return 0
    }
    this.remove = function(item) {
        item.selected = false
        var index = this.list.indexOf(item.id)
        if (index != -1) {
            this.list.splice(index, 1)
        }
        return index
    }
    this.isSelected = function(item) {
        // return (this.list.indexOf(item.id) != -1)
        return item.selected
    }
    this.addAll = function() {
        this.list = []
        for (var id in items) {
            items[id].selected = true
            this.list.push(parseInt(id,10))
        }
        return true
    }
    this.get = function(index) {
        return this.list[index]
    }
}




/**************************************************************************************************\
*                                    Position and Mouse objects                                    *
\**************************************************************************************************/


function Position(x, y) {
    this.x = x
    this.y = y
}

function Mouse() {
    this.x = null
    this.y = null
    this.updatePosition = function (e) {
        /* returns a copy of self (with .x and .y properties) */
        // This version also caches our mouse coordinates - mainly for use with key-press events
        if (e.pageX != undefined && e.pageY != undefined) {
            this.x = e.pageX
            this.y = e.pageY
        } else {
            this.x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft
            this.y = e.clientY + document.body.scrollTop  + document.documentElement.scrollTop
        }
        this.x -= canvasElement.offsetLeft
        this.y -= canvasElement.offsetTop
        
        return this
    }
    this.dragging = false
    this.dragStart = new Position(null, null)
    this.dragOffset = new Position(null, null)
    this.dragNoOffset = new Position(0, 0)
    this.startDrag = function () {
        if (!this.dragging) {
            this.dragging = true
            this.dragStart.x = this.x
            this.dragStart.y = this.y
            this.dragOffset.x = this.dragOffset.y = 0
            for (var index=selection.count(); --index>=0; ) {
                items[selection.get(index)].offset = this.dragOffset
            }
        }
    }
    this.doDrag = function () {
        if (this.dragging) {
            this.dragOffset.x = this.x - this.dragStart.x
            this.dragOffset.y = this.y - this.dragStart.y
//            for (var index=selection.count(); --index>=0; ) {
//                items[selection.get(index)].offset.x = this.dragOffset.x
//                items[selection.get(index)].offset.y = this.dragOffset.y
//            }
        }
    }
    this.stopDrag = function () {
        if (this.dragging) {
            if (selection.any()) {
                this.dragOffset.x = this.x - this.dragStart.x
                this.dragOffset.y = this.y - this.dragStart.y
                // one or more items selected - move them!
                for (var index = selection.count(); --index>=0; ) {
                    items[selection.get(index)].x += this.dragOffset.x
                    items[selection.get(index)].y += this.dragOffset.y
//                    items[selection.get(index)].offset.x = items[selection.get(index)].offset.y = 0
                    items[selection.get(index)].offset = this.dragNoOffset
                }
            }
            this.dragging = false
            this.dragStart.x = this.dragStart.y = this.dragOffset.x = this.dragOffset.y = null
        }
    }
    this.cancelDrag = function () {
        for (var index = selection.count(); --index>=0; ) {
//            items[selection.get(index)].offset.x = items[selection.get(index)].offset.y = 0
            items[selection.get(index)].offset = this.dragNoOffset
        }
        this.dragging = false
        this.dragStart.x = this.dragStart.y = this.dragOffset.x = this.dragOffset.y = null
    }
}
setObjProto(Mouse, Position)
var mouse = new Mouse()




/**************************************************************************************************\
*                                      Shape item definitions                                      *
\**************************************************************************************************/


function Item() {
    this.x = 0;
    this.y = 0;
    this.colour = "#fff"
    this.line_width = 3
    this.line_colour = "#777"
    this.cursorStyle = "pointer"
    this.visible = true
    this.selected = false
    this.offset = new Position(0,0)
}
// Set up the Item prototype.
// I think we are unlikely to create any Items, but we will set this as the __proto__ for other
//   item types, so that we can inherit (default) functions and values from Item

// Can define a single property like this:
// Item.prototype.test = function () {
//     return (1 == 1)
// }

// Can define multiple properties like this:
// Item.prototype = {
//     // note: we are completely replacing the prototype by doing this, so ought to preserve the
//     //   constructor property
//     // note: also, this method makes all additional properties - and the constructor - enumerable...
//     constructor: Item,
//     test: function() {
//         return (1 == 1)
//     }
// }

// Could also define a single property, with control of various flags, like this:
// Object.defineProperty(Item, "test", {
//     // note: all three of these flags default to false
//     // note: however, these flags are contained within an object, so in theory we could inherit
//     //   different 'default' values from the Object.prototype
//     // enumerable: if true, this property will show up during a "for (x in y)" loop
//     enumerable: false,
//     // configurable: if true, this property can be deleted, and have its type changed
//     configurable: false,
//     // writable: if true, the value of this property can be changed with an assignment operator
//     writable: false,
//     // value: the value of the property! can be any valid Javascript value (number, object,
//     //   function, etc)
//     value: function() {
//         return (1 == 1)
//     }
// });
// see here for more details:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#summary

defObjProp(Item.prototype, "draw", function(context, colour, line_colour) {
    switch (arguments.length) {
        case 0:  context = drawingContext
        case 1:  colour = this.colour
        case 2:  line_colour = this.line_colour
    }
    if (this.selected) {
        // item is selected
        if (selection.colour) colour = selection.colour
        if (selection.line_colour) line_colour = selection.line_colour
    }
    
    // not sure what to draw for a 'default' here... maybe a small cross, or something..?
} )

defObjProp(Item.prototype, "isMouseOver", function() {
    return ( (this.x == mouse.x) & (this.y == mouse.y) )
} )


function Rectangle(x, y, width, height, colour, line_width, line_colour) {
    // deal with default values for any missing arguments...
    // (borrowed from here: http://stackoverflow.com/a/9363769)
    switch (arguments.length) {
        case 2:  width = 10;
        case 3:  height = 10;
        case 4:  colour="#fff";
        case 5:  line_width=3;
        case 6:  line_colour="#777";
    }
    callParentConstructor(this)
    // this.type = "rectangle";
    // this.id = newItemId++;
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.colour = colour;
    this.line_width = line_width;
    this.line_colour = line_colour;

    this.draw = function (context, colour) {
        switch (arguments.length) {
            case 0:  context = drawingContext;
            case 1:  colour = this.colour;
        }
    }
}
setObjProto(Rectangle, Item)

function Circle(x, y, radius, colour, line_width, line_colour) {
    // deal with default values for any missing arguments...
    // (borrowed from here: http://stackoverflow.com/a/9363769)
    switch (arguments.length) {
        case 2:  radius = 10;
        case 3:  colour="#fff";
        case 4:  line_width=3;
        case 5:  line_colour="#777";
    }
    // Call the Item constructor function:
    // Item.call(this)
    // Object.getPrototypeOf(Object.getPrototypeOf(this)).constructor.call(this)
    callParentConstructor(this)
    // this.type = "circle";
    //  could instead use items[id].constructor.name (which gives "Circle")
    //  or items[id].constructior == Circle to see if an item is a Circle
    // this.id = newItemId++;
    //  now the id is initialised by items.add()...
    this.x = x;
    this.y = y;
    this.radius = radius;
    this.colour = colour;
    this.line_width = line_width;
    this.line_colour = line_colour;
    this.cursorStyle = "pointer";
}
setObjProto(Circle, Item)

// add some 'methods' to our genreal Circle.prototype
// this (I think) means that we only really have one instance of each function - it just gets called
//   with a different 'this' depending on which Circle is using it
//   (as apposed to defining them within the creator function above, in which case each new Circle
//   creates its own instance of each function - which must use more resources, surely..?)
// this also means we can make functions non-enumerable - probably less useful for Circles and the
//   like, but may be useful for other things...
defObjProp(Circle.prototype, "draw", function(context, colour, line_colour) {
    switch (arguments.length) {
        case 0:  context = drawingContext
        case 1:  colour = this.colour
        case 2:  line_colour = this.line_colour
    }
//    this.offset.x = 0
//    this.offset.y = 0
//    if (selection.isSelected(this)) {
    if (this.selected) {
        // item is selected
        if (selection.colour) colour = selection.colour
        if (selection.line_colour) line_colour = selection.line_colour
//        if (mouse.dragging) {
//            this.offset.x = mouse.dragOffset.x
//            this.offset.y = mouse.dragOffset.y
//        }
    }
    
    context.beginPath()
    context.arc(this.x+this.offset.x, this.y+this.offset.y, this.radius, 0, Math.PI*2, false)
    context.closePath()
    
    context.fillStyle = colour
	context.fill()
    
    context.strokeStyle = line_colour
    context.lineWidth = this.line_width
    context.stroke()
} )

defObjProp(Circle.prototype, "isMouseOver", function() {
    // var x2 = Math.pow(this.x - mouse.x,2)
    // var y2 = Math.pow(this.y - mouse.y,2)
    // var r = Math.sqrt(x2 + y2)
    // if (selection.isSelected(this) && mouse.dragging) {
//    if (this.selected && mouse.dragging) {
//        this.offset.x = mouse.dragOffset.x
//        this.offset.y = mouse.dragOffset.y
//    } else {
//        this.offset.x = 0
//        this.offset.y = 0
//    }
    return ( (Math.pow(this.x + this.offset.x - mouse.x,2) + Math.pow(this.y + this.offset.y - mouse.y,2)) <= Math.pow(this.radius,2) )
} )




/**************************************************************************************************\
*                                          Event handlers                                          *
\**************************************************************************************************/


// Mouse Click Events sequence:
// 1) MouseDown
// 2) MouseUp
// 3) Click
//
// 4) MouseDown
// 5) MouseUp
// 6) Click
// 7) DoubleClick
//
// Because the browser considers the canvas to be one element (it doesn't know about our 'items'),
// we tend to receive most of these even if the mouse moves about a bit between the MouseDown and
// MouseUp.  If the MouseDown happens outside the canvas, but the MouseUp happens within the canvas,
// then we don't get a Click after the MouseUp.  Pressing Escape between MouseDown and MouseUp
// doesn't appear to cancel the Click.  Doesn't seem to matter how long the pause between the
// MouseDown and MouseUp - we still get a Click.


function canvasMouseDown(e) {
    timings.add("MouseDown - start")
    // button detection needs improving, espeically if this is ever to become cross-browser compatible!.. see here:
    // http://javascript.info/tutorial/mouse-events#getting-the-button-info-which-button
    // or here:
    // http://www.quirksmode.org/js/events_properties.html#button
    if (e.button == 0) {
        // normal left-click
        
        // prevent default actions - in particular for a double click (tends to highlight some text around the canvas!..)
        e.preventDefault();
        // unfortunately this also prevents the canvas from getting the focus when we click on it, which prevents us from receiving KeyDown events...
        // see here for methods to work out if our convas has the focus at the moment (not straight forward!): http://www.whatwg.org/specs/web-apps/current-work/#focus-management-apis
        if ( !(document.hasFocus() && (document.activeElement == canvasElement)) ) {
            // Now, 'manually' pulling focus to the canvas like this seems to move the window around (which I don't really want), so...
            // (window.scrollX and .scrollY don't seem to work..? although they should do! see here:
            // https://developer.mozilla.org/en-US/docs/Web/API/window.scrollY
            // and here:
            // http://stackoverflow.com/questions/3791336/why-were-window-scrolly-and-window-scrollx-introduced )
            // var scroll_x = window.pageXOffset;
            // var scroll_y = window.pageYOffset;
            // This is more robust across various browsers...
            var scroll_x = (window.pageXOffset !== undefined) ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;
            var scroll_y = (window.pageYOffset !== undefined) ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
            canvasElement.focus();
            window.scroll(scroll_x,scroll_y);
        }
        mouse.updatePosition(e);
        
        // try to work out if we have clicked on an existing item or not...
        var this_item = which_item()
        
        if (this_item == -1) {
            // we've clicked in empty space...
            if (selection.any()) {
                // one or more items currently selected - unselect everything
                selection.clear();
            } else {
                // nothing currently selected - do nothing for now..?
            }
        } else {
            // we've clicked on an item...
            
            if (!e.shiftKey && !e.ctrlKey && !e.altKey && !e.altGraphKey && !e.metaKey) {
                // straight forward click - select this item only
                // ...unless this item is already selected (or part of a larger selection), in which case don't change anything...
                // if (!selection.isSelected(items[this_item])) {
                if (!items[this_item].selected) {
                    // not currently selected - select it!
                    selection.solo(items[this_item])
                }
            } else if (e.shiftKey && !e.ctrlKey && !e.altKey && !e.altGraphKey && !e.metaKey) {
                // shift-click - add this item to the selection (if not already selected!)
                selection.add(items[this_item])
            } else if (!e.shiftKey && e.ctrlKey && !e.altKey && !e.altGraphKey && !e.metaKey) {
                // control-click - toggle this item 'selected' state
                // is this item already selected..?
                // if (selection.isSelected(items[this_item])) {
                if (items[this_item].selected) {
                    // yes - remove it from the list!
                    selection.remove(items[this_item]);
                } else {
                    // no - add it to the list!
                    selection.add(items[this_item]);
                }
            } else {
                // some other form of click... do nothing..?
            }
            
            mouse.startDrag()
        }
  
        // update canvas
        draw();
        // update mouse pointer
        setCursorStyle(this_item);
    } else {
        // right-click (or maybe middle-click?)
    }
    timings.add("MouseDown - end")
}

// This gets called just after a mouse up event - regardless of whether there's been any mouse movment... (on Chrome on my Chromebook)
function canvasClick(e) {
    // currently, all the code that was here is now in MouseDown, above... 
    timings.add("Click - start/end")
}

// this is very similar to MouseOut, below...
function canvasMouseUp(e) {
    timings.add("MouseUp - start")
    if (mouse.dragging) {
        mouse.updatePosition(e);
        mouse.stopDrag()
        
        // not certain if we really need to re-draw here or not...
        // ... but I guess that the mouse could have moved since we received out last mouseMove
        //   event..?
        draw();
        // update mouse pointer
        setCursorStyle(which_item());
    }
    timings.add("MouseUp - end")
}

// this is very similar to MouseUp, above...
function canvasMouseOut(e) {
    timings.add("MouseOut - start")
    if (mouse.dragging) {
        mouse.updatePosition(e);
        mouse.stopDrag()

        // not certain if we really need to re-draw here or not...
        draw();
    }
    // update mouse pointer
    setCursorStyle(-1);
    timings.add("MouseOut - end")
}

// This gets called when the user double clicks with a mouse (or on a touch screen..?)
// When the user double clicks with a mouse, we receive one Click event for the first click, then a second Click event followed by a DoubleClick event for the second click
function canvasDoubleClick(e) {
    timings.add("DoubleClick - start")
    mouse.updatePosition(e);

    // try to work out if we have clicked on an existing item or not...
    var this_item = which_item()

    if (this_item == -1) {
        // double click not on an item - add a new circle to our items list, where we clicked...
        // add it to the list, and update this_item - mainly for the benefit of the call to
        //   setCursor below
        items.add(new Circle(mouse.x, mouse.y, 10+Math.floor(Math.random()*11)));
        this_item = which_item()
    } else {
        // we've double clicked on an item...
        // erm... do nothing for now..? - nope!
        
        // select only this item
        selection.solo(items[this_item])
    }
    
    // prevent default actions for a double click (tends to highlight some text around the canvas!..)
    // e.preventDefault();
    // this doesn't work - we need to prevent mouse-down events, above...
    // ... or with canvasElement.onselectstart, down below (in init)

    // update canvas
    draw();
    // update mouse pointer
    setCursorStyle(this_item);
    timings.add("DoubleClick - end")
}

function canvasMouseMove(e) {
    mouse.updatePosition(e);
    if (mouse.dragging) {
        timings.add("MouseMove-dragging - start")
        mouse.doDrag()
        draw()
        timings.add("MouseMove-dragging - end")
    }

    // try to work out if we are over an existing item or not...
    var itemId = which_item()
    setCursorStyle(itemId);

    thisIdElement.innerHTML = itemId;
}

function canvasKeyDown(e) {
    // if we want to prevent the Backspace button from moving us to the previous page in the browser
    //   history, then we need to catch the KeyDown event (for e.keyIdentifier = "U+0008") and run
    //   e.preventDefault()
    // note: the move to the previous page normally happens on the key down event, so if we wait for
    //   the key up event it'll be too late!.. (in Chrome, on my Chromebook, at least...)
    switch (e.keyIdentifier) {
    case "U+007F": // Delete (alt-backspace)
    case "U+0008": // Backspace
        if (selection.any()) {
            // one or more items selected - delete them!
            selection.delete();
            draw();
            setCursorStyle(which_item());

        }
        e.preventDefault();
        break;
    case "U+0041": // A
        if (e.ctrlKey && !e.shiftKey && !e.altKey && !e.altGraphKey && !e.metaKey) {
            // Ctrl-A - select all items!
            selection.addAll();
            e.preventDefault();
            draw();
            setCursorStyle(which_item());
        } else {
            // do nothing..?
        }
        break;
    case "U+001B": // Esc
        if (mouse.dragging) {
            // cancel the drag
            mouse.cancelDrag()
            draw();
            setCursorStyle(which_item());
        } else {
            // do nothing..?
        }
        break;
    case "U+0050": // P
        if (!e.ctrlKey && !e.shiftKey && e.altKey && !e.altGraphKey && !e.metaKey) {
            // Alt-P
            breakpoint()
        }
        break;
    }
}

// go through all the items (in reverse stacking order) to see which, if any, we are over
function which_item() {
    for (var index = stack.count(); --index>=0; ) {
        if (items[stack.get(index)].isMouseOver()) return stack.get(index);
    }
    return -1;
}

function setCursorStyle(id) {
    if (mouse.dragging) {
		canvasElement.style.cursor = "move";
    } else if (id == -1) {
        // not over any existing items
		canvasElement.style.cursor = "default";
    } else {
        // over an item
        var cursor;
        if (items[id].getCursorStyle !== undefined) cursor = items[id].getCursorStyle();
        if (cursor === undefined) cursor = items[id].cursorStyle;
        if (cursor === undefined) cursor = "default";
        canvasElement.style.cursor = cursor;
    }
}

function draw() {
    timings.add("draw - start")
    // start from scratch - clear the whole canvas
    drawingContext.clearRect(0, 0, canvasWidth, canvasHeight);

    // draw our background
    var gradient = drawingContext.createLinearGradient(0, 0, canvasWidth, canvasHeight);
    gradient.addColorStop(0, "#d0d0d0");
    gradient.addColorStop(1, "#fbfbfb");
    // gradient.addColorStop(0, "#ff0000");
    // gradient.addColorStop(0.25, "#ffff00");
    // gradient.addColorStop(0.5, "#00ff00");
    // gradient.addColorStop(0.75, "#00ffff");
    // gradient.addColorStop(1, "#0000ff");
    drawingContext.fillStyle = gradient;
    // drawingContext.fillStyle = "#eee";
    drawingContext.fillRect(0, 0, canvasWidth, canvasHeight)

    var count = stack.count()
    for (var index = 0; index<count; index++) {
	    // drawItem(items[i]);
        items[stack.get(index)].draw();
    }

    counterElement.innerHTML = items.length;
    nextIdElement.innerHTML = items.nextItemId;
    timings.add("draw - end", true)
}

function init(canvas, counter, nextId) {
    // check if canvas already exists in the html document, and create one if not
    if (!canvas) {
        canvas = document.createElement("canvas");
    	canvas.id = "canvas";
    	document.body.appendChild(canvas);
    }
    canvasElement = canvas;
    // set the height and width of out canvas
    canvasElement.width = canvasWidth;
    canvasElement.height = canvasHeight;
    canvasElement.tabIndex = 1;
    // get the drawign context for the canvas
    drawingContext = canvasElement.getContext("2d");

    // listen out for clicks
    //canvasElement.addEventListener("click", canvasClick, false);
    // listen out for double-clicks
    canvasElement.addEventListener("dblclick", canvasDoubleClick, false);
    // listen out for mouse down events
    canvasElement.addEventListener("mousedown", canvasMouseDown, false);
    // ... and for mouse moves
    canvasElement.addEventListener("mousemove", canvasMouseMove, false);
    // ... and for mouse up events
    canvasElement.addEventListener("mouseup", canvasMouseUp, false);
    // ... and for mouse out events
    canvasElement.addEventListener("mouseout", canvasMouseOut, false);
    // ... and for key-down events
    // note: the canvas element doesn't take the input focus when clicked on, so therefore it doesn't receive any key events
    // document.body.addEventListener("keydown", bodyKeyDown, false);
    // okay, if you give the canvas element a tabindex, then it can and will take the input focus!..
    // (this information found here: http://stackoverflow.com/a/57332)
    canvasElement.addEventListener("keydown", canvasKeyDown, false);
    // prevent double-clicks on the canvas from selecting a block of text
    // (may not work well across browsers..?)
    canvasElement.onselectstart = function() { return false; }

    // check if a counter already exists in the html document, and create one if not
    if (!counter) {
        counter = document.createElement("p");
	    document.body.appendChild(counter);
    }
    counterElement = counter;

    // check if a 'next id' already exists in the html document, and create one if not
    if (!nextId) {
        nextId = document.createElement("p");
	    document.body.appendChild(nextId);
    }
    nextIdElement = nextId;

    // check if a 'next id' already exists in the html document, and create one if not
    thisIdElement = document.getElementById('thisId');
    if (!thisId) {
        thisIdElement = document.createElement("p");
	    document.body.appendChild(thisIdElement);
    }

    // set up a bunch of random circles...
    for (var i = 0; i < 100; i++) {
        items.add(new Circle(Math.floor(Math.random() * canvasWidth), Math.floor(Math.random() * canvasHeight), 10+Math.floor(Math.random()*11)));
    }
  
    // do an initial drawing of our (blank?) canvas
    draw();
}
 </script>
 <title>Canvas 8</title>
</head>
<body>
 <h1>Canvas Development #8</h1>
 <p>Double-click anywhere in the square to draw a circle!</p>
 <div style="float: left; height: 320px; width: 315px; overflow: auto;">
  <!-- use "overflow: scroll;" to make scroll bars always visible -->
  <!-- It looks like, in Chrome on my Chromebook, the width of the parent div needs to be at least 15px greater than the canvas, and the height at least 20px greater, for the scroll bars to deactivate -->
  <canvas id="myCanvas" width="100" height="100"></canvas>
 </div>
 <p>Number of items: <span id="counter">-1</span><br />
    Next unique item id: <span id="nextId">-1</span><br />
    This item id: <span id="thisId">-1</span><br />
    Click on a circle to select it, shift-click to add to your selection, or control-click to toggle selection.<br />
    Press backsapce/delete to delete selected circles!<br />
    (note: if nothing is selected, then backspace will do it's default action, which is to go to the previous page in your browser's history...)<br />
    (also note: the canvas needs to have the input focus (shown by a blue halo) to catch any keyboard events)<br />
    Ctrl-A will select all circles.<br />
    Internally, started change towards a more 'object-oriented' approach... (circles are more object-y; so is the selection list; and the list of items)<br />
    Double-clicking now supported - double click to create a circle, and double-click on a circle to select only it!<br />
    Internally separated out the stacking order from the list of items - hopefully a useful move in the future!..<br />
    Also started making more use of prototypes... Circles now inherit from a new Item type, and generic Circle functions are contained in the Circle.prototype, rather than in each Circle instance individually (I think this is an efficient move..?)<br />
    Finally!.. Added the ability to move a circle - or a selection of multiple circles! :-)<br />
    Internally, created a 'mouse' object to rememebr where the mouse is - for key press events and the like.  This also meant I could tidy a few other bits up and move a couple of functions within the 'mouse' object.<br />
    Internally, added a 'selected' property to each item - I think this should speed a few things up, as we won't have to scan through the entire list of selected items to work out if something is selected - which we need to do every time we re-draw an item, so dragging (lots of) items around should be smoother...  Also used in Item.isMouseOver, to work out if we need to apply an offset to our known position.
 </p>
 <script>
   init(document.getElementById('myCanvas'), document.getElementById('counter'), document.getElementById('nextId'));
 </script>
</body>
</html>